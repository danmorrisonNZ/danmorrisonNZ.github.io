<!DOCTYPE html>
<html>

  <head>
    <link type="text/css" rel="stylesheet" href="../blog/blog-stylesheet.css"/>
    <title>Dan Morrison Blog</title>
  <head>

  <body>

    <div id="navigation">

      <p>Dan Morrison Blog</p>

      <div class="item"><br>
        <a href="#">Archive</a>
        <ul>
          <li><a href="c1-chefs-kitchen.html">9th Nov<br>CB </a></li><br>
          <li><a href="t1-git-blog.html">9th Nov<br>TB</a></li>
          <li><a href="t2-css-design.html">22nd Nov<br>TB</a></li>
          <li><a href="t3-arrays-hashes.html">23rd Nov<br>TB</a></li>
        </ul>
      </div>

      <div class="item">
        <ul>
          <li><a href="https://twitter.com/Dan_Morrison">Twitter</a></li>
          <li><a href="https://github.com/danmorrisonNZ">Github</a></li>
          <li><a href="http://danmorrisonnz.github.io/index.html">Website</a></li>
        </ul>
      </div>

    </div>

    <div id="content">

      <h1>Phase 0 Week 3</h1>
      <h3>Thinking Style</h3>
      <p>23rd November 2014</p>
      <p>This Weeks Cultural blog is on Thinking Styles.<br><br>
      It was interesting to find that my particular thinking style is that of a Concrete Random thinker, mostly because it seems to fit in pretty well with my Briggs-Myers result of ENTJ. I'm open to experimenting and taking risks but fall short in repeating tasks, probably largely due to the "do it once, do it right" attitude. <br><br>
      I always find these types of self reflexive tests interesting though, as it provides insight into personal shortcomings so that I might be able to address them in the future; or at least become a bit more self aware.
      <br><br>
      I think the two things I'll need to address going forward are the aversion to repeating tasks and the frustration with having to choose a single answer. As Ive learnt in Dev Academy so far, theres not always time to be a perfectionist which I think these particular traits only amplify. <br>Strategy wise, I really need to let certain things go, and be ok with leaving a task in a less than ideal state (in my opinion at least). If I can meet the learning outcomes and come back to them later for further study, then my time management should improve greatly.

      Dan

      </p>

       <h1>Phase 0 Week 3</h1>
      <h3>On Arrays and Hashes</h3>
      <p>23rd November 2014</p>
      <p>This weeks technical blog is on the difference between Arrays and Hashes.
      <br><br>
      Before we get into the details lets look at the bigger picture. Arrays and Hashes are both ways of creating librarys of data. That is to say you can store different values within them. Say you really like cats; infact you like them so much that you have twenty of them. But your memory is also starting to fade and you need a way to keep track of all their names. You can create an Array or Hash to store all these names and call on them later depending on your preffered way of referencing.
      <br><br>
      This is where the major difference between the two comes in. While both store librarys of data, each piece of data in an Array is referenced with a number with the first number being 0, the second being 1, the third being 2 and so on and so forth. Hashs on the other hand are structured slightly differently; each piece of data in a hash is referenced with a key rather than a number. The key can be anything a name, a number, what ever you like, but you decide what it is.
      So while an Array will operate like this:
      <br><br>
      ['molly', 'ringo', 'butch', 'sunny', 'gutenburg'] <br>
      With molly being number 0, ringo being number 1, butch being number 2, etc.<br><br>
      A hash will operate more like this:<br><br>
      ['blackspot' => 'molly', 'glasses' => 'ringo', 'fatty' => 'butch', 'smiles' => 'sunny', 'paperman' => 'gutenburg']<br>
      With Mollys reference being 'blackspot', ringos reference being 'glasses' etc.<br><br>
      Both have their advantages namely being that Arrays are more useful for high effeciency tasks given their ability to be ordered and retrieved via numbers, and Hashs are more flexable, allowing for a greater level of specifity and reference if thats crucial to the task.

      Dan
    </p>

      <h1>Phase 0 Week 2</h1>
      <h3>CSS Positioning</h3>
      <p>22 November 2014</p>
      <p>A bit of a late one this week but here we go! This weeks Technical Blog is on CSS Positioning and the difference between the Absolute, Relative and Fixed states.
      <br><br>
      Before we jump into the specifics lets preface the whole topic with a bit of analogue context. Imagine each browser window as a white piece of magical paper.A landscape rectangle with the ability to change size at will. Now imagine an element in that browser window, say, an image, or a block of text, as a coloured square of paper on top of your white piece of paper. This is how elements in a website work, they can be placed on top of each other, next to each other and can be placed off the page all together if you want them to be. <br>
      Now instead of moving them with our hands we need to move them with code, and thats where CSS positioning comes in.
      <br><br>
      <strong>Fixed Positioning</strong>
      Fixed positioning is relative to your browsers window.
      This means that a fixed element will always stay in its position no matter where your browser window goes.
      In the following 3 images you can see how my left hand navigation and right hand about section are both fixed and will stay in their positions no matter if I scroll down on the page, or if I re-size the window.
      <img src="Imgs/Fixed1.png" />
      <img src="Imgs/Fixed2.png" />
      <img src="Imgs/Fixed3.png" />
      In fact you can even try it on this window, go ahead and try resizing the window to see how the fixed elements behave in real time.
      <br><br>
      <strong>Relative Positioning</strong>
      Relative positioning is relative to itself. That might sound confusing but really all you need to think of it as, is fixed positioning with a bit more wiggle room. Where as fixed position is positioned relative to the browser window, relative postioning is relative to where ever it thinks it is. In practice this means you can position a relative element, then scroll down the page, and the relative element will magically dissapear into the top of the window. You can try that right now as well, click on the archive button on the left hand side and try scrolling down to see what happens.
      <br><br>
      <strong>Absolute Positioning</strong>
      Abosolute Positioning takes the law into its own hands. Where Fixed and Relative positioning go with the flow of the page and play nicely together, Absolute positioning plays by its own rules. An aboslute element doesn't care if your fixed or relative elements are pushing everything over to the right, it'll stay right where it is. Think of it as gluing one of those pieces of paper from earlier to your original page. Absolute elements can be placed anywhere and are relative to their parent elements (meaning the next element up that isn't static) or if there is no parent element then to the HTML tags.
      <br><br>
      I've run out of time for this weeks post though so hopefully thats explained well enough for now!
      <br><br>
      Until next time
      <br><br>
      Dan

      </p>
      <br><br>
      <h1>Phase 0 Week 1</h1>
      <h3>Cultural Blog - EDA Experience</h3>
      <p>9th November 2014</p>
      <p>Starting phase zero has been a bit of a whirlwind. All of the new information has been borderline overwhelming, but I can already tell that I'm going to get exactly what I'be been expecting out of the course in it's entirety.<br><br>

      Last week I had no Idea how to do anything in the terminal or what Git or Github were, and now I'm commiting and pushing files with ease.<br><br>

      After watching the video of Shereef's Fireside Chat, my impressions of EDA haven't really changed at all.
      I've always thought that this would be about learning to learn, rather than learning to code. Sure as a by product I'll come out of it with skills in Ruby, Javascript etc. But really the time spent on this is about a set of techniques and challenging what we've been traditionally taught to accept as a learning outcome.<br><br>

      Empathy appears to be a big point, working with nice people, being nice to people, understanding how to build great things for other nice people. It's something I'm really excited about as my goals with this are to have the core skills sit along side my design background, which also utilises empathy as a key method of achieving excellence.<br><br>

      All in all I'm still almost overwhelmed by the different emotions circling in my head right now, and I dont expect that to stop during my time at EDA. But it's a good thing, I'm unsure of my own knowledge base, but excited to get stuck into learning new things and engaging with new people. I'm sure with empathy as a core tenet of the EDA experience we're all sure to help each other along the way to a new and exciting future.<br><br>

      Dan
      </p>
      <h1>Phase 0 Week 1</h1>
      <h3>On Version control, git tracking, and Github</h3>
      <p>9 November 2014</p>
      <p>This week for challenge ten of EDA we're writing about Version Control, Git tracking and Github.<br><br>

      I myself have only been learning about this for a short while now so feel free to let me know if theres anything im getting wrong.<br><br>


      Everyones had this problem at one point in their lives. Whether you're writing an essay for school, a report for work, or creating a file in Illustrator, we've all overwritten our main file only to find out six overwrites down the track that we deleted a paragraph that's now necessary, or converted some text to paths that now needs changing.<br><br>

      Its a major hassle.<br><br>

      Version control helps to avoid this hassle by saving an individual copy of your file every time you change it. If you make a mistake on version twelve and need to go back to version ten, then you can.<br><br>

      Now lets apply this to a development context.<br><br>

      In development we have a Version Control system called Git.<br>
      Git allows us to view previous changes we've made to our files by viewing a log of those changes. On top of that we can also create separate versions of our files called "Branches" where we can try weird and wacky things. If the experementing doesnt work then we can simply delete a branch and the original files will still be there. This is great for individuals but where it really starts to shine is on collaborative projects.<br><br>

      Enter Github<br><br>

      We use Github as a sort of dropbox for coding collaboration. By sharing folders or "Repositories" with other developers we are able to all work on parts of a project at the same time. When I've finished my part I'll save or "commit" a version on my computer, and then push that up to the shared folder or "remote-repository". When all these systems work together great things begin to happen. Git makes sure that you dont overwrite each others files, but can instead merge them all togther. I can be working on part 1 and you can be working on part 2, and instead of my part 1 overwriting your part 2, it will merge them together in the repository.<br><br>

      All of this makes Git and Github ideal for developers, making collaborative development much easier.<br><br>

      Thats it for the first post Ill be back next week with something else new and exciting!<br><br>

      Dan

      </p>
      </div>

      <div id="about">
      <img src ="imgs/profile4.png"/>
      <div id="abouttext">
      <p>I'm Dan a Designer and soon to be developer. Follow my journeys here.</p>
      </div>
      </div>






  </body>

</html>